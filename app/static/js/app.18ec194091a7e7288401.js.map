{"version":3,"sources":["webpack:///./src/App.vue?5975","webpack:///./src/App.vue","webpack:///src/App.vue","webpack:///./src/assets/praatio.js","webpack:///src/components/HelloWorld.vue","webpack:///./src/components/HelloWorld.vue?d148","webpack:///./src/components/HelloWorld.vue","webpack:///./src/router/index.js","webpack:///./src/main.js"],"names":["selectortype_template_index_0_src_App","render","_h","this","$createElement","_c","_self","attrs","id","staticRenderFns","src_App","__webpack_require__","normalizeComponent","name","ssrContext","INTERVAL_TIER","POINT_TIER","MIN_INTERVAL_LENGTH","fillInBlanks","tier","blankLabel","arguments","length","undefined","startTime","endTime","minTimestamp","maxTimestamp","entryList","push","slice","entry","prevEnd","parseFloat","newEntryList","i","newStart","newEnd","Error","splice","IntervalTier","removeUltrashortIntervals","minLength","j","_tier$entryList$i","slicedToArray_default","start","stop","label","diff","Math","abs","newCopy","extended_split","str","separator","max","out","index","next","indexOf","substring","findAllSubstrings","sourceStr","subStr","indexList","fetchRow","dataStr","searchStr","startIndex","endIndex","word","trim","TextgridTier","minT","maxT","classCallCheck_default","tierType","minTime","maxTime","appendTier","editTimestamps","allowOvershoot","sort","x","y","matchLabel","substrMatchFlag","usingRE","returnList","match","includes","_ref","_ref$name","_ref$entryList","_ref$minTimestamp","_ref$maxTimestamp","constructor","retTier","insertEntry","PointTier","timeList","map","_ref2","_ref3","timeV","min","apply","toConsumableArray_default","_this","possibleConstructorReturn_default","__proto__","get_prototype_of_default","call","cropStart","cropEnd","mode","rebaseToZero","timestamp","startTimeList","_ref4","_ref5","endTimeList","concat","_this2","matchedEntry","intervalStart","intervalEnd","intervalLabel","Textgrid","tierNameList","tierDict","tierIndex","keys_default","newTG","tierName","newTier","crop","addTier","textgrid","oldName","newName","oldTier","removeTier","fn","minimumIntervalLength","outputTxt","getAsText","readTextgrid","text","replace","data","intervalIndicies","pointIndicies","tupleList","headerList","split","tgMin","tgMax","blockStartI","blockEndI","isInterval","tierData","_fetchRow11","_fetchRow12","_fetchRow13","_fetchRow14","tierStartTime","_fetchRow15","_fetchRow16","tierEndTime","startTimeI","endTimeI","labelI","_fetchRow17","_fetchRow18","_fetchRow19","_fetchRow20","_fetchRow21","_fetchRow22","_fetchRow23","_fetchRow24","_fetchRow25","_fetchRow26","parseShortTextgrid","tierList","textgridHeader","shift","tierTxt","searchWord","tmpArray","header","tierStart","tierEnd","console","log","timeStartI","timeStart","timeEnd","_fetchRow","_fetchRow2","_fetchRow3","_fetchRow4","_fetchRow5","_fetchRow6","timePointI","timePoint","_fetchRow7","_fetchRow8","_fetchRow9","_fetchRow10","parseNormalTextgrid","HelloWorld","msg","methods","ondrop","event","preventDefault","className","document","getElementById","files","dataTransfer","toLowerCase","loadFromLocal","tgLoaded","ondragover","ondragleave","file","handler","reader","FileReader","onload","fd","target","result","readAsText","outputFn","tg","praatio","csv","tgToCsv","innerText","download","content","fileName","contentType","a","createElement","Blob","type","href","URL","createObjectURL","click","pivotTierName","tierNameArray","colHeader","table","subTG","row","subLabel","subTier","join","mounted","dropzone","components_HelloWorld","_m","staticClass","_v","src_components_HelloWorld","HelloWorld_normalizeComponent","Vue","use","Router","router","routes","path","component","config","productionTip","el","components","App","template"],"mappings":"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","file":"static/js/app.18ec194091a7e7288401.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('router-view')],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-0e232033\",\"hasScoped\":false,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/App.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-0e232033\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/vue-loader/lib/selector?type=styles&index=0!./App.vue\")\n}\nvar normalizeComponent = require(\"!../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./App.vue\"\n/* template */\nimport __vue_template__ from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-0e232033\\\",\\\"hasScoped\\\":false,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./App.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/App.vue\n// module id = null\n// module chunks = ","<template>\n  <div id=\"app\">\n    <router-view/>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App'\n}\n</script>\n\n<style>\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/App.vue","/*\nWritten by Tim Mahrt\nMarch 25, 2015\n\nreadTextgrid() will read in a textgrid in JSON format, ready to be processed by the\nuser.\n\nTODO: add writeTextgrid()?\n\nThis is a translation of the file reading and writing capabilities of the python praatio\nlibrary.\n*/\nconst INTERVAL_TIER = 'interval_tier';\nconst POINT_TIER = 'point_tier';\nconst MIN_INTERVAL_LENGTH = 0.00000001; // Arbitrary threshold\n\nfunction fillInBlanks (tier, blankLabel = '', startTime = null, endTime = null) {\n  /*\n  Fills in the space between intervals with empty space\n\n  This is necessary to do when saving to create a well-formed textgrid\n  */\n\n  if (startTime === null) startTime = tier.minTimestamp;\n  if (endTime === null) endTime = tier.maxTimestamp;\n\n  // Special case: empty textgrid\n  if (tier.entryList.length === 0) tier.entryList.push([startTime, endTime, blankLabel]);\n\n  // Create a new entry list\n  let entryList = tier.entryList.slice();\n  let entry = entryList[0];\n  let prevEnd = parseFloat(entry[1]);\n  let newEntryList = [entry, ];\n\n  for (let i = 1; i < entryList.length; i++) {\n    let newStart = parseFloat(entryList[i][0]);\n    let newEnd = parseFloat(entryList[i][1]);\n\n    if (prevEnd < newStart) newEntryList.push([prevEnd, newStart, blankLabel]);\n\n    newEntryList.push(entryList[i]);\n\n    prevEnd = newEnd;\n  }\n\n  // Special case: If there is a gap at the start of the file\n  if (parseFloat(newEntryList[0][0]) < parseFloat(startTime)) {\n    throw new Error('Tier data is before the tier start time.');\n  }\n  if (parseFloat(newEntryList[0][0]) > parseFloat(startTime)) {\n    newEntryList.splice(0, 0, [startTime, newEntryList[0][0], blankLabel]);\n  }\n\n  // Special case: If there is a gap at the end of the file\n  if (endTime !== null) {\n    if (parseFloat(newEntryList[-1][1]) > parseFloat(endTime)) {\n      throw new Error('Tier data is after the tier end time.');\n    }\n    if (parseFloat(newEntryList[-1][1]) < parseFloat(endTime)) {\n      newEntryList.splice([newEntryList[-1][1], endTime, blankLabel]);\n    }\n  }\n\n  return new IntervalTier(tier.name, newEntryList, tier.minTimestamp, tier.maxTimestamp);\n}\n\n\nfunction removeUltrashortIntervals (tier, minLength) {\n  /*\n  Remove intervals that are very tiny\n\n  Doing many small manipulations on intervals can lead to the creation\n  of ultrashort intervals (e.g. 1*10^-15 seconds long).  This function\n  removes such intervals.\n  */\n\n  // First, remove tiny intervals\n  let newEntryList = [];\n  let j = 0;\n  for (let i = 0; i < tier.entryList.length; i++) {\n    let [start, stop, label] = tier.entryList[i];\n    if (stop - start < minLength) {\n      // Correct ultra-short entries\n      if (newEntryList.length > 0) {\n        newEntryList[j - 1] = (newEntryList[j - 1], stop, newEntryList[j - 1]);\n      }\n    } else {\n      // Special case: the first entry in oldEntryList was ultra-short\n      if (newEntryList.length === 0 && start !== 0) {\n        newEntryList.push([0, stop, label]);\n      } else // Normal case\n      {\n        newEntryList.push([start, stop, label]);\n      }\n      j += 1;\n    }\n  }\n\n  // Next, shift near equivalent tiny boundaries\n  j = 0;\n  while (j < newEntryList.length - 1) {\n    let diff = Math.abs(newEntryList[j][1] - newEntryList[j + 1][0]);\n    if (diff > 0 && diff < MIN_INTERVAL_LENGTH) {\n      newEntryList[j] = [newEntryList[j][0], newEntryList[j + 1][0], newEntryList[j][2]];\n    }\n  }\n\n  return tier.newCopy({\n    entryList: newEntryList\n  });\n}\n\n// Python-like split from\n// http://stackoverflow.com/questions/6131195/javascript-splitting-string-from-the-first-comma\nfunction extended_split (str, separator, max) {\n  let out = [],\n    index = 0,\n    next;\n\n  while (!max || out.length < max - 1) {\n    next = str.indexOf(separator, index);\n    if (next === -1) {\n      break;\n    }\n    out.push(str.substring(index, next));\n    index = next + separator.length;\n  }\n  out.push(str.substring(index));\n  return out;\n}\n\nfunction findAllSubstrings (sourceStr, subStr) {\n  let indexList = [],\n    index = sourceStr.indexOf(subStr);\n  while (index !== -1) {\n    indexList.push(index);\n    index += 1;\n\n    index = sourceStr.indexOf(subStr, index);\n  }\n  return indexList;\n}\n\nfunction fetchRow (dataStr, searchStr, index) {\n  let startIndex = dataStr.indexOf(searchStr, index) + searchStr.length;\n  let endIndex = dataStr.indexOf('\\n', startIndex);\n\n  let word = dataStr.substring(startIndex, endIndex);\n  word = word.trim();\n\n  if (word[0] === '\"' && word[word.length - 1] === '\"') {\n    word = word.substring(1, word.length - 1);\n  }\n  word = word.trim();\n\n  // Increment the index by 1, unless nothing was found\n  if (endIndex !== -1) endIndex += 1;\n\n  return [word, endIndex];\n}\n\nfunction strToIntOrFloat (inputStr) {\n  let retNum = null;\n  if (inputStr.includes('.')) {\n    retNum = parseFloat(inputStr);\n  } else {\n    retNum = parseInt(inputStr);\n  }\n  return retNum;\n}\n\nclass TextgridTier {\n\n  constructor (name, entryList, minT, maxT) {\n    this.name = name;\n    this.entryList = entryList;\n    this.minTimestamp = minT;\n    this.maxTimestamp = maxT;\n    this.tierType = null;\n  }\n\n  appendTier (tier) {\n    let minTime = this.minTimestamp;\n    if (tier.minTimestamp < minTime) minTime = tier.minTimestamp;\n\n    let maxTime = this.maxTimestamp + tier.maxTimestamp;\n\n    let appendTier = tier.editTimestamps(this.maxTimestamp, allowOvershoot = true);\n\n    if (this.tierType !== tier.tierType) {\n      throw new Error('Tier types must match when appending tiers.');\n    }\n\n    let entryList = this.entryList + appendTier.entryList;\n    entryList.sort(function(x, y) {\n      return x[0] < x[1];\n    });\n\n    return this.newCopy(this.name, entryList, minTime, maxTime);\n  }\n\n  deleteEntry (entry) {\n    let i = this.entryList.indexOf(entry);\n    this.entryList.splice(i, 1);\n  }\n\n  find (matchLabel, substrMatchFlag, usingRE) {\n    let returnList = [];\n    for (let i = 0; i < this.entryList.length; i++) {\n      if (usingRE === true) {\n        if (this.entryList[i].match(matchLabel)) returnList.push(i);\n      } else if (substrMatchFlag === false) {\n        if (this.entryList[i] === matchLabel) returnList.push(i);\n      } else {\n        if (this.entryList[i].includes(matchLabel)) returnList.push(i);\n      }\n    }\n    return returnList;\n  }\n\n  newCopy({\n    name = null,\n    entryList = null,\n    minTimestamp = null,\n    maxTimestamp = null\n  } = {}) {\n    if (name === null) name = this.name;\n    if (entryList === null) entryList = this.entryList;\n    if (minTimestamp === null) minTimestamp = this.minTimestamp;\n    if (maxTimestamp === null) maxTimestamp = this.maxTimestamp;\n\n    return this.constructor(name, entryList, minTimestamp, maxTimestamp);\n  }\n\n  sort () {\n    this.entryList.sort(function(x, y) {\n      return x[0] < x[1];\n    });\n  }\n\n  union (tier) {\n    let retTier = this.newCopy();\n\n    for (let i = 0; i < tier.entryList.length; i++) {\n      retTier.insertEntry(tier.entryList[i], false, 'merge');\n    }\n  }\n}\n\nclass PointTier extends TextgridTier {\n  constructor (name, entryList, minT = null, maxT = null) {\n    entryList = entryList.map(([timeV, label]) => [parseFloat(timeV), label]);\n\n    // Determine the min and max timestamps\n    let timeList = entryList.map(entry => entry[0]);\n    if (minT !== null) timeList.push(parseFloat(minT));\n    if (maxT !== null) timeList.push(parseFloat(maxT));\n\n    minT = Math.min(...timeList);\n    maxT = Math.max(...timeList);\n\n    // Finish intialization\n    super(name, entryList, minT, maxT);\n    this.tierType = 'TextTier';\n  }\n\n  crop (cropStart, cropEnd, mode, rebaseToZero = true) {\n    /*\n    Creates a new tier containing all entires inside the new interval\n\n    mode is ignored.  This parameter is kept for compatibility with\n    IntervalTier.crop()\n    */\n    let newEntryList = [];\n\n    for (let i = 0; i < this.entryList.length; i++) {\n      let timestamp = this.entryList[i][0];\n      if (timestamp >= cropStart && timestamp <= cropEnd) newEntryList.push(this.entryList[i]);\n    }\n\n    let minT = cropStart;\n    let maxT = cropEnd;\n    if (rebaseToZero === true) {\n      newEntryList = newEntryList.map(entry => [entry[0] - cropStart, entry[1]]);\n      minT = 0;\n      maxT = cropEnd - cropStart;\n    }\n\n    let subTier = new PointTier(this.name, newEntryList, minT, maxT);\n    return subTier;\n  }\n}\n\nclass IntervalTier extends TextgridTier {\n  constructor (name, entryList, minT = null, maxT = null) {\n    entryList = entryList.map(([startTime, endTime, label]) => [parseFloat(startTime), parseFloat(endTime), label]);\n\n    // Determine the min and max timestamps\n    let startTimeList = entryList.map(entry => entry[0]);\n    let endTimeList = entryList.map(entry => entry[1]);\n    let timeList = startTimeList.concat(endTimeList);\n\n    if (minT !== null) timeList.push(parseFloat(minT));\n    if (maxT !== null) timeList.push(parseFloat(maxT));\n\n    minT = Math.min(...startTimeList);\n    maxT = Math.max(...endTimeList);\n\n    // Finish initialization\n    super(name, entryList, minT, maxT);\n    this.tierType = 'IntervalTier';\n  }\n  crop (cropStart, cropEnd, mode, rebaseToZero) {\n    /*\n    Creates a new tier with all entries that fit inside the new interval\n\n    mode = {'strict', 'lax', 'truncated'}\n        If 'strict', only intervals wholly contained by the crop\n            interval will be kept\n        If 'lax', partially contained intervals will be kept\n        If 'truncated', partially contained intervals will be\n            truncated to fit within the crop region.\n\n    If rebaseToZero is true, the cropped textgrid values will be\n        subtracted by the cropStart\n    */\n    let newEntryList = [];\n    for (let i = 0; i < this.entryList.length; i++) {\n      let entry = this.entryList[i];\n      let matchedEntry = null;\n\n      let intervalStart = entry[0];\n      let intervalEnd = entry[1];\n      let intervalLabel = entry[2];\n\n      // Don't need to investigate if the interval is before or after\n      // the crop region\n      if (intervalEnd <= cropStart || intervalStart >= cropEnd) continue;\n\n      // Determine if the current subEntry is wholly contained\n      // within the superEntry\n      if (intervalStart >= cropStart && intervalEnd <= cropEnd) {\n        matchedEntry = entry;\n      }\n\n      // If it is only partially contained within the superEntry AND\n      // inclusion is 'lax', include it anyways\n      else if (mode === 'lax' && (intervalStart >= cropStart || intervalEnd <= cropEnd)) {\n        matchedEntry = entry;\n      }\n\n      // If not strict, include partial tiers on the edges\n      // -- regardless, record how much information was lost\n      //        - for strict=true, the total time of the cut interval\n      //        - for strict=false, the portion of the interval that lies\n      //            outside the new interval\n\n      // The current interval stradles the end of the new interval\n      else if (intervalStart >= cropStart && intervalEnd > cropEnd) {\n        if (mode === 'truncated') {\n          matchedEntry = [intervalStart, cropEnd, intervalLabel];\n        }\n      }\n\n      // The current interval stradles the start of the new interval\n      else if (intervalStart < cropStart && intervalEnd <= cropEnd) {\n        if (mode === 'truncated') {\n          matchedEntry = [cropStart, intervalEnd, intervalLabel];\n        }\n      }\n\n      // The current interval contains the new interval completely\n      else if (intervalStart <= cropStart && intervalEnd >= cropEnd) {\n        if (mode === 'lax') {\n          matchedEntry = entry;\n        } else if (mode === 'truncated') {\n          matchedEntry = [cropStart, cropEnd, intervalLabel];\n        }\n      }\n\n      if (matchedEntry !== null) {\n        newEntryList.push(matchedEntry);\n      }\n    }\n\n    let minT = cropStart;\n    let maxT = cropEnd;\n    if (rebaseToZero === true) {\n      newEntryList = newEntryList.map(entryList => [entryList[0] - cropStart,\n        entryList[1] - cropStart,\n        entryList[2]\n      ]);\n      minT = 0;\n      maxT = cropEnd - cropStart;\n    }\n\n    // Create subtier\n    let croppedTier = new IntervalTier(this.name, newEntryList, minT, maxT);\n\n    return croppedTier;\n  }\n}\n\nclass Textgrid {\n  constructor () {\n    this.tierNameList = [];\n    this.tierDict = {};\n\n    this.minTimestamp = null;\n    this.maxTimestamp = null;\n  }\n\n  addTier (tier, tierIndex = null) {\n    if (Object.keys(this.tierDict).includes(tier.name)) {\n      throw new Error('Tier name already exists in textgrid');\n    }\n\n    if (tierIndex === null) this.tierNameList.push(tier.name);\n    else this.tierNameList.splice(tierIndex, 0, tier.name);\n\n    this.tierDict[tier.name] = tier;\n\n    if (this.minTimestamp === null || tier.minTimestamp < this.minTimestamp) {\n      this.minTimestamp = tier.minTimestamp;\n    }\n\n    if (this.maxTimestamp === null || tier.maxTimestamp > this.maxTimestamp) {\n      this.maxTimestamp = tier.maxTimestamp;\n    }\n  }\n\n  crop (cropStart, cropEnd, mode, rebaseToZero) {\n    /*\n    Creates a textgrid where all intervals fit within the crop region\n\n    mode = {'strict', 'lax', 'truncated'}\n        If 'strict', only intervals wholly contained by the crop\n            interval will be kept\n        If 'lax', partially contained intervals will be kept\n        If 'truncated', partially contained intervals will be\n            truncated to fit within the crop region.\n\n    If rebaseToZero is true, the cropped textgrid values will be\n        subtracted by the cropStart\n    */\n    let newTG = new Textgrid();\n\n    let minT = cropStart;\n    let maxT = cropEnd;\n    if (rebaseToZero === true) {\n      minT = 0;\n      maxT = cropEnd - cropStart;\n    }\n\n    newTG.minTimestamp = minT;\n    newTG.maxTimestamp = maxT;\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      let tierName = this.tierNameList[i];\n      let tier = this.tierDict[tierName];\n      let newTier = tier.crop(cropStart, cropEnd, mode, rebaseToZero);\n      newTG.addTier(newTier);\n    }\n\n    return newTG;\n  }\n\n  newCopy () {\n    let textgrid = new Textgrid();\n    for (let i = 0; i < this.tierNameList; i++) {\n      let tierName = this.tierNameList[i];\n      textgrid.tierNameList.push(tierName);\n      textgrid.tierDict[tierName] = this.tierDict[tierName];\n    }\n\n    textgrid.minTimestamp = this.minTimestamp;\n    textgrid.maxTimestamp = this.maxTimestamp;\n\n    return textgrid;\n  }\n\n  renameTier (oldName, newName) {\n    let oldTier = this.tierDict[oldName];\n    let tierIndex = this.tierNameList.indexOf(oldName);\n    this.removeTier(oldName);\n    this.addTier(oldTier, tierIndex);\n  }\n\n  removeTier (name) {\n    this.tierNameList.splice(this.tierNameList.index(name), 1);\n    delete this.tierDict[name];\n  }\n\n  replaceTier (name, newTier) {\n    let tierIndex = this.tierNameList.indexOf(name);\n    this.removeTier(name);\n    this.addTier(newTier, tierIndex);\n  }\n\n  getOutputText (fn, minimumIntervalLength = MIN_INTERVAL_LENGTH) {\n    /*\n    Formats the textgrid for saving to a .TextGrid fileimumIntervalLength is null, then ultrashortintervals\n    will not be checked for.\n    */\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      this.tierDict[this.tierNameList[i]].sort();\n    }\n\n    // Fill in the blank spaces for interval tiers\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      let tierName = this.tierNameList[i];\n      let tier = this.tierDict[tierName];\n\n      if (tier instanceof IntervalTier) {\n        tier = fillInBlanks(tier, '', this.minTimestamp, this.maxTimestamp);\n        if (minimumIntervalLength !== null) {\n          tier = removeUltrashortIntervals(tier, minimumIntervalLength);\n        }\n        this.tierDict[name] = tier;\n      }\n    }\n\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      this.tierDict[this.tierNameList[i]].sort();\n    }\n\n    // Header\n    let outputTxt = '';\n    outputTxt += 'File type = \"ooTextFile short\"\\n';\n    outputTxt += 'Object class = \"TextGrid\"\\n\\n';\n    outputTxt += '${this.minTimestamp}\\n${this.maxTimestamp}\\n';\n    outputTxt += '<exists>\\n${this.tierNameList}\\n';\n\n    for (let i = 0; i < this.tierNameList.length; i++) {\n      outputTxt += this.tierDict[this.tierNameList[i]].getAsText();\n    }\n\n    return outputTxt;\n  }\n}\n\nfunction parseNormalTextgrid (data) {\n  // Toss header\n  let tierList = data.split('item [');\n  let textgridHeader = tierList.shift();\n\n  let tgMin = parseFloat(textgridHeader.split('xmin = ', 2)[1].split('\\n', 1)[0].trim());\n  let tgMax = parseFloat(textgridHeader.split('xmax = ', 2)[1].split('\\n', 1)[0].trim());\n\n  // Process each tier individually\n  //tierList = data.split('item');\n  //tierList = tierList[1,tierList.length];\n  let tierTxt = '';\n  tierList.shift(); // Removing the document root empty item\n  let textgrid = new Textgrid();\n  textgrid.minTimestamp = tgMin;\n  textgrid.maxTimestamp = tgMax;\n\n  for (let i = 0; i < tierList.length; i++) {\n    tierTxt = tierList[i];\n\n    // Get tier type\n    let tierType = POINT_TIER;\n    let searchWord = 'points';\n    if (tierTxt.indexOf('class = \"IntervalTier\"') > -1) {\n      tierType = INTERVAL_TIER;\n      searchWord = 'intervals';\n    }\n\n    // Get tier meta-information\n    let tmpArray = extended_split(tierTxt, searchWord, 2);\n    let header = tmpArray[0];\n    let tierData = tmpArray[1];\n    let tierName = header.split('name = ', 2)[1].split('\\n', 1)[0].trim();\n    tierName = tierName.slice(1, tierName.length - 1); // remove quotes\n    let tierStart = header.split('xmin = ', 2)[1].split('\\n', 1)[0].trim();\n    let tierEnd = header.split('xmax = ', 2)[1].split('\\n', 1)[0].trim();\n\n    // Get the tier entry list\n    let entryList = [];\n    let labelI = 0;\n    let label = null;\n    let tier = null;\n    console.log(tierType)\n    if (tierType === INTERVAL_TIER) {\n      let timeStartI = null;\n      let timeEndI = null;\n      let timeStart = null;\n      let timeEnd = null;\n      while (true) {\n        [timeStart, timeStartI] = fetchRow(tierData, 'xmin = ', labelI);\n\n        // Break condition here.  indexof loops around at the end of a file\n        if (timeStartI <= labelI) break;\n\n        [timeEnd, timeEndI] = fetchRow(tierData, 'xmax = ', timeStartI);\n        [label, labelI] = fetchRow(tierData, 'text =', timeEndI);\n\n        label = label.trim();\n        if (label === '') continue;\n\n        entryList.push([parseFloat(timeStart), parseFloat(timeEnd), label]);\n      }\n      tier = new IntervalTier(tierName, entryList, tierStart, tierEnd);\n    } else {\n      let timePointI = null;\n      let timePoint = null;\n      while (true) {\n        [timePoint, timePointI] = fetchRow(tierData, 'number = ', labelI);\n\n        // Break condition here.  indexof loops around at the end of a file\n        if (timePointI <= labelI) break;\n\n        [label, labelI] = fetchRow(tierData, 'mark =', timePointI);\n\n        label = label.trim();\n        if (label === '') continue;\n\n        entryList.push([parseFloat(timePoint), label]);\n      }\n      tier = new PointTier(tierName, entryList, tierStart, tierEnd);\n    }\n    textgrid.addTier(tier);\n  }\n  return textgrid;\n}\n\nfunction parseShortTextgrid (data) {\n  let indexList = [];\n\n  let intervalIndicies = findAllSubstrings(data, '\"IntervalTier\"');\n  for (let i = 0; i < intervalIndicies.length; i++) {\n    indexList.push([intervalIndicies[i], true]);\n  }\n\n  let pointIndicies = findAllSubstrings(data, '\"TextTier\"');\n  for (let i = 0; i < pointIndicies.length; i++) {\n    indexList.push([pointIndicies[i], false]);\n  }\n\n  indexList.push([data.length, null]); // The 'end' of the file\n  indexList.sort(function (x, y) {\n    return x[0] < x[1];\n  });\n\n  let tupleList = [];\n  for (let i = 0; i < indexList.length - 1; i++) {\n    tupleList.push([indexList[i][0], indexList[i + 1][0], indexList[i][1]]);\n  }\n\n  // Set the textgrid's min and max times\n  let header = data.slice(0, tupleList[0][0]);\n  let headerList = header.split('\\n');\n  let tgMin = parseFloat(headerList[3]);\n  let tgMax = parseFloat(headerList[4]);\n\n  // Add the textgrid tiers\n  let textgrid = new Textgrid();\n  textgrid.minTimestamp = tgMin;\n  textgrid.maxTimestamp = tgMax;\n\n  for (let i = 0; i < tupleList.length; i++) {\n    let tier = null;\n\n    let blockStartI = tupleList[i][0];\n    let blockEndI = tupleList[i][1];\n    let isInterval = tupleList[i][2];\n\n    let tierData = data.slice(blockStartI, blockEndI);\n\n    let metaStartI = fetchRow(tierData, '', 0)[1];\n\n    // Tier meta-information\n    let [tierName, tierNameEndI] = fetchRow(tierData, '', metaStartI);\n    let [tierStartTime, tierStartTimeI] = fetchRow(tierData, '', tierNameEndI);\n    let [tierEndTime, tierEndTimeI] = fetchRow(tierData, '', tierStartTimeI);\n    let startTimeI = fetchRow(tierData, '', tierEndTimeI)[1];\n\n    tierStartTime = parseFloat(tierStartTime);\n    tierEndTime = parseFloat(tierEndTime);\n\n    // Tier entry data\n    let startTime = null;\n    let endTime = null;\n    let label = null;\n    let tierType = null;\n    let endTimeI = null;\n    let labelI = null;\n\n    let entryList = [];\n    if (isInterval === true) {\n      while (true) {\n        [startTime, endTimeI] = fetchRow(tierData, '', startTimeI);\n        if (endTimeI === -1) break;\n\n        [endTime, labelI] = fetchRow(tierData, '', endTimeI);\n        [label, startTimeI] = fetchRow(tierData, '', labelI);\n\n        label = label.trim();\n        if (label === '') continue;\n        entryList.push([startTime, endTime, label]);\n      }\n      tier = new IntervalTier(tierName, entryList, tierStartTime, tierEndTime);\n    } else {\n      while (true) {\n        [startTime, labelI] = fetchRow(tierData, '', startTimeI);\n        if (labelI === -1) break;\n\n        [label, startTimeI] = fetchRow(tierData, '', labelI);\n\n        label = label.trim();\n        if (label === '') continue;\n        entryList.push([startTime, label]);\n      }\n      tier = new PointTier(tierName, entryList, tierStartTime, tierEndTime);\n    }\n    textgrid.addTier(tier);\n  }\n\n  return textgrid;\n}\n\nfunction readTextgrid (text) {\n  text = text.replace(/\\r\\n/g, '\\n');\n\n  let textgrid;\n  if (text.indexOf('ooTextFile short') !== -1 || text.indexOf('item') === -1) {\n    textgrid = parseShortTextgrid(text);\n  } else {\n    textgrid = parseNormalTextgrid(text);\n  }\n\n  return textgrid;\n}\n\nexport default readTextgrid;\n\n\n\n// WEBPACK FOOTER //\n// ./src/assets/praatio.js","<template>\n  <div>\n    <div class=\"dropzone\" id=\"dropzone\">\n      Drop files here\n    </div>\n    <br /><br />\n    <div class=\"displayarea\" id=\"displayarea\"></div>\n  </div>\n</template>\n\n<script>\nimport readTextgrid from '../assets/praatio.js'\nexport default {\n  name: 'TgToCsv',\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  },\n  methods: {\n    ondrop (event) {\n      event.preventDefault()\n      this.className = 'dropzone'\n\n      var fileInput = document.getElementById('dropzone')\n      var fileDisplayArea = document.getElementById('displayarea')\n\n      var files = event.dataTransfer.files\n\n      for (var i = 0; i < files.length; i++) {\n        var name = files[i].name\n\n        if (name.toLowerCase().includes('.textgrid')) {\n          this.loadFromLocal(files[i], this.tgLoaded)\n        }\n      }\n    },\n    ondragover () {\n      this.className = 'dropzone dragover'\n      return false\n    },\n    ondragleave () {\n      this.className = 'dropzone'\n      return false\n    },\n    loadFromLocal (file, handler) {\n      let reader = new FileReader()\n      reader.onload = function (fd) {\n        let data = fd.target.result\n        handler(file, data)\n      }\n      reader.readAsText(file)\n    },\n\n    tgLoaded (file, data) {\n      let outputFn = file.name.split('.')[0] + '.csv'\n      let tg = readTextgrid(data)\n      let csv = this.tgToCsv(tg, 'Vowel', ['Word', 'Vowel', 'Syllableid', 'Stress', 'Error'])\n      document.getElementById('displayarea').innerText = csv\n      this.download(csv, outputFn, 'text/plain')\n    },\n\n    download (content, fileName, contentType) {\n      // https://stackoverflow.com/questions/34156282/how-do-i-save-json-to-local-text-file\n      var a = document.createElement('a')\n      var file = new Blob([content], {type: contentType})\n      a.href = URL.createObjectURL(file)\n      a.download = fileName\n      a.click()\n    },\n\n    tgToCsv (tg, pivotTierName, tierNameArray) {\n      let colHeader = tierNameArray.slice()\n      colHeader.push('Start Time')\n      colHeader.push('End Time')\n      let table = [colHeader]\n      console.log(tg.tierNameList)\n      console.log(pivotTierName)\n      let tier = tg.tierDict[pivotTierName]\n      for (let i = 0; i < tier.entryList.length; i++) {\n        let start = tier.entryList[i][0]\n        let stop = tier.entryList[i][1]\n        // let label = tier.entryList[i][2]\n\n        let subTG = tg.crop(start, stop, 'truncated', false)\n\n        let row = []\n        for (let j = 0; j < tierNameArray.length; j++) {\n          let subLabel = ''\n          if (subTG.tierNameList.includes(tierNameArray[j])) {\n            let subTier = subTG.tierDict[tierNameArray[j]]\n            if (subTier.entryList.length > 0) {\n              subLabel = subTier.entryList[0][2]\n            }\n          }\n          row.push(subLabel)\n        }\n        row.push(start)\n        row.push(stop)\n        table.push(row)\n      }\n\n      table = table.map(row => row.join(','))\n      let csv = table.join('\\n')\n\n      return csv\n    }\n  },\n  mounted () {\n    let dropzone = document.getElementById('dropzone')\n    dropzone.ondrop = this.ondrop\n    dropzone.ondragover = this.ondragover\n    dropzone.ondragleave = this.ondragleave\n  }\n}\n</script>\n\n<style scoped>\n.dropzone {\n  height: 100px;\n  width: 200px;\n  border: 1px solid black;\n}\n\n.displayarea {\n  width: 1000px;\n  height: 400px;\n  border: 1px solid black;\n}\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/components/HelloWorld.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:\"dropzone\",attrs:{\"id\":\"dropzone\"}},[_vm._v(\"\\n    Drop files here\\n  \")]),_vm._v(\" \"),_c('br'),_c('br'),_vm._v(\" \"),_c('div',{staticClass:\"displayarea\",attrs:{\"id\":\"displayarea\"}})])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-222e0641\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/HelloWorld.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-222e0641\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../node_modules/vue-loader/lib/selector?type=styles&index=0!./HelloWorld.vue\")\n}\nvar normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./HelloWorld.vue\"\nimport __vue_script__ from \"!!babel-loader!../../node_modules/vue-loader/lib/selector?type=script&index=0!./HelloWorld.vue\"\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-222e0641\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!./HelloWorld.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-222e0641\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/HelloWorld.vue\n// module id = null\n// module chunks = ","import Vue from 'vue'\nimport Router from 'vue-router'\nimport HelloWorld from '@/components/HelloWorld'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'HelloWorld',\n      component: HelloWorld\n    }\n  ]\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/router/index.js","// The Vue build version to load with the `import` command\n// (runtime-only or standalone) has been set in webpack.base.conf with an alias.\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  components: { App },\n  template: '<App/>'\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}